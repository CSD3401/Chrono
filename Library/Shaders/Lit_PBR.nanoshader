#type vertex
#version 460 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;

uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;
uniform mat4 u_NormalMatrix;

out vec3 v_Normal;
out vec3 v_FragPos;
out vec2 v_TexCoord;

void main() {
    vec4 world = u_Model * vec4(aPos, 1.0);
    v_FragPos = world.xyz;
    v_Normal  = mat3(u_NormalMatrix) * a_Normal;
    v_TexCoord = a_TexCoord;
    gl_Position = u_Projection * u_View * world;
}


#type fragment
#version 460 core
#extension GL_ARB_bindless_texture : require

#define MAX_LIGHTS 12
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2

in vec3 v_Normal;
in vec3 v_FragPos;
in vec2 v_TexCoord;

out vec4 FragColor;

// ===== Scene / Lighting =====
uniform vec3 		u_CameraPos;
uniform vec3 		u_AmbientColor; // simple ambient for now to move to scene-wide ambient/IBL tint in the future

// Base (albedo)
uniform vec3 u_BaseColor;
uniform sampler2D 	u_AlbedoMap;
uniform int 		u_HasAlbedoMap;

// Normal
uniform sampler2D 	u_NormalMap;
uniform int 		u_HasNormalMap;

// Roughness / Metallic
uniform float 		u_Roughness;
uniform sampler2D 	u_RoughnessMap;
uniform int 		u_HasRoughnessMap;

uniform float 		u_Metallic;
uniform sampler2D 	u_MetallicMap;
uniform int 		u_HasMetallicMap;

// Ambient Occlusion
uniform float 		u_AmbientOcclusion;
uniform sampler2D 	u_AmbientOcclusionMap;
uniform int 		u_HasAOMap;

// Displacement Mapping
uniform sampler2D 	u_DisplacementMap;   // height map (R channel 0..1)
uniform int 		u_HasDisplacementMap;
uniform float 		u_ParallaxScale;     // e.g. 0.02 .. 0.06 (world-agnostic scalar)
uniform float 		u_ParallaxMid;       // usually 0.5 if mid-gray = no height

uniform int 		u_ParallaxMode; 	// Parallax mode: 0 = off, 1 = simple parallax offset, 2 = POM
uniform int 		u_ParallaxInvert;

// POM quality (dynamic layer count by angle)
uniform int       u_ParallaxMinLayers; // e.g. 16
uniform int       u_ParallaxMaxLayers; // e.g. 48

// NEW: border clipping controls
uniform int   u_ParallaxClipBorders;  // 0=off, 1=hard clip, 2=smart clip
uniform float u_ParallaxEdgeFade;     // smart-clip ring width in UV units (e.g. 0.04)

struct Light {
    int   type; // 0 = directional, 1 = point, 2 = spot
    vec3  color;
    float intensity;

    vec3  position;
    vec3  direction;

    float constant;
    float linear;
    float quadratic;

    float innerCutoff;    // cos(innerAngle)
    float outerCutoff;    // cos(outerAngle)
};

uniform int u_numLights;
uniform Light u_lights[MAX_LIGHTS];

uniform vec3  u_Emissive;

const float PI = 3.14159265359;

float EdgeFade(vec2 uv, float edgeWidth) {
    if (edgeWidth <= 0.0) return 1.0; // disabled
    float d = min(min(uv.x, uv.y), min(1.0 - uv.x, 1.0 - uv.y));
    return smoothstep(0.0, edgeWidth, d); // 0 at edge -> 1 in the middle
}

vec3 srgb_to_linear(vec3 c) {
    bvec3 cutoff = lessThanEqual(c, vec3(0.04045));
    vec3 low  = c / 12.92;
    vec3 high = pow((c + 0.055) / 1.055, vec3(2.4));
    return mix(high, low, vec3(cutoff));
}

vec3 linear_to_srgb(vec3 c) {
    bvec3 cutoff = lessThanEqual(c, vec3(0.0031308));
    vec3 low  = c * 12.92;
    vec3 high = 1.055 * pow(max(c, 0.0), vec3(1.0/2.4)) - 0.055;
    return clamp(mix(high, low, vec3(cutoff)), 0.0, 1.0);
}

float DistributionGGX(float NdotH, float roughness)
{
    float a      = max(roughness, 0.04);
    float a2     = a * a;
    float denom  = (NdotH * NdotH) * (a2 - 1.0) + 1.0;
    return a2 / max(PI * denom * denom, 1e-6);
}

float GeometrySchlickGGX(float NdotX, float roughness)
{
    float r = max(roughness, 0.04);
    float k = (r + 1.0);
    k = (k * k) / 8.0;
    return NdotX / max(NdotX * (1.0 - k) + k, 1e-6);
}

float GeometrySmith(float NdotV, float NdotL, float roughness)
{
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

vec3 FresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 BRDF_GGX_Smith(vec3 N, vec3 V, vec3 L, vec3 albedo, float metallic, float roughness)
{
    vec3  H     = normalize(V + L);
    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);
    float NdotH = max(dot(N, H), 0.0);
    float VdotH = max(dot(V, H), 0.0);

    if (NdotL <= 0.0 || NdotV <= 0.0) return vec3(0.0);

    // Base reflectance
    vec3 F0 = mix(vec3(0.04), albedo, metallic);

    // Your helpers are assumed to take the scalar forms (as in your code):
    float D = DistributionGGX(NdotH, roughness);
    float G = GeometrySmith(NdotV, NdotL, roughness);
    vec3  F = FresnelSchlick(VdotH, F0);

    vec3  numeratorSpec = D * G * F;
    float denom         = max(4.0 * NdotV * NdotL, 1e-6);
    vec3  specular      = numeratorSpec / denom;

    vec3  Ks = F;
    vec3  Kd = (1.0 - Ks) * (1.0 - metallic);
    vec3  diffuse = (Kd * albedo) / PI;

    return (diffuse + specular) * NdotL;
}

mat3 ComputeTBN(vec3 N, vec3 P, vec2 uv)
{
    vec3 dp1 = dFdx(P);
    vec3 dp2 = dFdy(P);
    vec2 duv1 = dFdx(uv);
    vec2 duv2 = dFdy(uv);

    vec3 T = normalize(dp1 * duv2.y - dp2 * duv1.y);
    vec3 B = normalize(cross(N, T));
    return mat3(T, B, N);
}

// --- Simple Parallax Offset (cheap) ---
vec2 ParallaxOffset_Basic(vec2 uv, vec3 viewTS, float scale, float mid)
{
    // viewTS is the view vector in tangent space
    float h = texture(u_DisplacementMap, uv).r - mid;   // center around mid (e.g., 0.5)
    // Push along view direction projected onto the surface
    vec2 offset = (viewTS.xy / max(viewTS.z, 1e-5)) * (h * scale);
    return uv - offset;
}

// --- Parallax Occlusion Mapping (ray-march) + linear refinement ---
//vec2 ParallaxOffset_POM(vec2 uv, vec3 viewTS, float scale, bool invertHeight, int minL, int maxL)
//{
//    float ndotv  = clamp(abs(viewTS.z), 0.0, 1.0);
//    float layers = mix(float(maxL), float(minL), ndotv);   // more layers at grazing
//    float layerDepth = 1.0 / layers;
//
//    // Total parallax shift in UVs (projected along view)
//    vec2 totalParallax = (viewTS.xy / max(viewTS.z, 1e-5)) * scale;
//    vec2 dUV = totalParallax / layers;
//
//    // March
//    float currentLayerDepth = 0.0;     // goes 0..1
//    vec2  currUV = uv;
//    float heightSample = texture(u_DisplacementMap, currUV).r;
//    if (invertHeight) heightSample = 1.0 - heightSample;
//
//    // Compare "how far we've marched" vs "surface height"
//    while (currentLayerDepth < heightSample) {
//        currUV -= dUV;
//        currentLayerDepth += layerDepth;
//
//        // Early out if we step off the UVs (prevents dark seams)
//        if (any(lessThan(currUV, vec2(0.0))) || any(greaterThan(currUV, vec2(1.0))))
//            break;
//
//        heightSample = texture(u_DisplacementMap, currUV).r;
//        if (invertHeight) heightSample = 1.0 - heightSample;
//    }
//
//    // Step back one layer and linearly refine along the last segment
//    vec2  prevUV = currUV + dUV;
//    float prevLayerDepth = currentLayerDepth - layerDepth;
//
//    float hAfter  = heightSample - currentLayerDepth;
//    float hBefore = (texture(u_DisplacementMap, prevUV).r * (invertHeight ? -1.0 : 1.0) + (invertHeight ? 1.0 : 0.0)) - prevLayerDepth;
//
//    float w = hBefore / max((hBefore - hAfter), 1e-5);
//    vec2 refinedUV = mix(currUV, prevUV, clamp(w, 0.0, 1.0));
//    return refinedUV;
//}

vec2 ParallaxOffset_POM(vec2 uv,
                        vec3 viewTS,
                        float scale,
                        bool invertHeight,
                        int minL, int maxL,
                        out bool offEdge)
{
    offEdge = false;

    // More layers at grazing angles
    float ndotv  = clamp(abs(viewTS.z), 0.0, 1.0);
    float layers = mix(float(maxL), float(minL), ndotv); // 0->grazing=maxL, 1->front=minL
    float layerDepth = 1.0 / layers;

    // Total UV shift along the view direction
    vec2 totalParallax = (viewTS.xy / max(viewTS.z, 1e-5)) * scale;
    vec2 dUV = totalParallax / layers;

    // March forward until depth >= height
    float currentLayerDepth = 0.0;
    vec2  currUV = uv;

    float h = texture(u_DisplacementMap, currUV).r;
    if (invertHeight) h = 1.0 - h;

    while (currentLayerDepth < h) {
        currUV -= dUV;
        currentLayerDepth += layerDepth;

        // If we walked off the UVs, mark and stop
        if (any(lessThan(currUV, vec2(0.0))) || any(greaterThan(currUV, vec2(1.0)))) {
            offEdge = true;
            return currUV; // early out; caller can decide to discard
        }

        h = texture(u_DisplacementMap, currUV).r;
        if (invertHeight) h = 1.0 - h;
    }

    // Linear refinement between last two samples
    vec2  prevUV = currUV + dUV;
    float prevLayerDepth = currentLayerDepth - layerDepth;

    float hPrev = texture(u_DisplacementMap, prevUV).r;
    if (invertHeight) hPrev = 1.0 - hPrev;

    float fPrev = hPrev - prevLayerDepth;
    float fCurr = h     - currentLayerDepth;

    float w = fPrev / max(fPrev - fCurr, 1e-5);
    return mix(currUV, prevUV, clamp(w, 0.0, 1.0));
}

// ===== Light evaluators =====
vec3 EvalDirectional(in Light Lgt, vec3 N, vec3 V, vec3 albedo, float metallic, float roughness)
{
    vec3 L = normalize(-Lgt.direction);
    vec3 brdf = BRDF_GGX_Smith(N, V, L, albedo, metallic, roughness);
    vec3 radiance = Lgt.color * Lgt.intensity;
    return brdf * radiance;
}


vec3 EvalPoint(in Light Lgt, vec3 N, vec3 V, vec3 P, vec3 albedo, float metallic, float roughness)
{
    vec3  Ldir = Lgt.position - P;
    float dist2 = dot(Ldir, Ldir);
    float d     = sqrt(dist2);
    if (d <= 0.0) return vec3(0.0);

    vec3 L = Ldir / d;

    float atten = 1.0 / max(Lgt.constant + Lgt.linear * d + Lgt.quadratic * dist2, 1e-6);

    vec3 brdf     = BRDF_GGX_Smith(N, V, L, albedo, metallic, roughness);
    vec3 radiance = Lgt.color * Lgt.intensity * atten;
    return brdf * radiance;
}

vec3 EvalSpot(in Light Lgt, vec3 N, vec3 V, vec3 P, vec3 albedo, float metallic, float roughness)
{
    vec3  Ldir = Lgt.position - P;
    float dist2 = dot(Ldir, Ldir);
    float d     = sqrt(dist2);
    if (d <= 0.0) return vec3(0.0);

    vec3 L = Ldir / d;

    float theta = dot(L, normalize(-Lgt.direction));
    float inner = Lgt.innerCutoff;
    float outer = Lgt.outerCutoff;
    float eps   = max(inner - outer, 1e-4);
    float spot  = clamp((theta - outer) / eps, 0.0, 1.0);

    if (spot <= 0.0) return vec3(0.0);

    float atten = 1.0 / max(Lgt.constant + Lgt.linear * d + Lgt.quadratic * dist2, 1e-6);

    vec3 brdf     = BRDF_GGX_Smith(N, V, L, albedo, metallic, roughness);
    vec3 radiance = Lgt.color * Lgt.intensity * atten * spot;
    return brdf * radiance;
}

void main()
{
	vec2 uv = v_TexCoord;

    // view/normal
    vec3 V = normalize(u_CameraPos - v_FragPos);
    vec3 N = normalize(v_Normal);

	mat3 TBN = ComputeTBN(N, v_FragPos, uv);
	vec3 Vts = normalize(transpose(TBN) * V);
	
	// --- Parallax UV adjustment ---
	//if (u_HasDisplacementMap != 0 && u_ParallaxMode != 0) {
	//	if (u_ParallaxMode == 1) {
	//		// Simple offset â€” if you keep "mid", it's fine here
	//		uv = ParallaxOffset_Basic(uv, Vts, u_ParallaxScale, u_ParallaxMid);
	//	} else { // POM
	//		bool invertH = (u_ParallaxInvert != 0);
	//		uv = ParallaxOffset_POM(uv, Vts, u_ParallaxScale, invertH,
	//								u_ParallaxMinLayers, u_ParallaxMaxLayers);
	//	}
	//	uv = clamp(uv, vec2(0.0), vec2(1.0));
	//}
	
	if (u_HasDisplacementMap != 0 && u_ParallaxMode == 2) {
		// View direction in world
		vec3 V = normalize(u_CameraPos - v_FragPos);

		// Convert to tangent space (world->tangent)
		vec3 viewTS = normalize(transpose(TBN) * V);

		// Run POM
		bool offEdge = false;
		vec2 uvPOM = ParallaxOffset_POM(
			uv,
			viewTS,
			u_ParallaxScale,
			(u_ParallaxInvert != 0),
			u_ParallaxMinLayers,
			u_ParallaxMaxLayers,
			offEdge
		);

		// --- Border handling ---
		if (u_ParallaxClipBorders != 0 && offEdge) {
			if (u_ParallaxClipBorders == 1) {
				// Hard alpha cutout
				discard;
			} else {
				// Smart clip: only cut when we're not right on the UV edge
				float edgeOk = EdgeFade(uv, u_ParallaxEdgeFade); // 0 at edge, 1 inside
				if (edgeOk > 0.7) discard;
			}
		}

		// Use the parallaxed coords for all subsequent sampling
		uv = clamp(uvPOM, vec2(0.0), vec2(1.0));
	}

    // Albedo
    //vec3 albedo = clamp(u_BaseColor, 0.0, 1.0);
    //if (u_HasAlbedoMap != 0) {
    //    albedo *= texture(u_AlbedoMap, uv).rgb;
    //}
	vec3 albedo = srgb_to_linear(clamp(u_BaseColor, 0.0, 1.0));
	if (u_HasAlbedoMap != 0) {
		vec3 albedoTex = texture(u_AlbedoMap, uv).rgb;   // sRGB texture
		albedo *= srgb_to_linear(albedoTex);
	}

    // Normal
    if (u_HasNormalMap != 0) {
        vec3 n = texture(u_NormalMap, uv).xyz * 2.0 - 1.0;  // [-1,1]
        //mat3 TBN = ComputeTBN(N, v_FragPos, uv);
        N = normalize(TBN * n);
    }

    // Roughness
    float roughness = clamp(u_Roughness, 0.04, 1.0);
    if (u_HasRoughnessMap != 0) {
        roughness = texture(u_RoughnessMap, uv).r;
    }

    // Metallic
    float metallic = clamp(u_Metallic, 0.0, 1.0);
    if (u_HasMetallicMap != 0) metallic = texture(u_MetallicMap, uv).r;

    // Ambient Occlusion
    float ao = clamp(u_AmbientOcclusion, 0.0, 1.0);
    if (u_HasAOMap != 0) {
        ao = texture(u_AmbientOcclusionMap, uv).r;
    }

    // === ambient and direct lighting ===
    vec3 ambient = u_AmbientColor * albedo * ao;

    vec3 Lo = vec3(0.0);
    for (int i = 0; i < u_numLights; ++i) {
        if (u_lights[i].type == 0)
            Lo += EvalDirectional(u_lights[i], N, V, albedo, metallic, roughness);
        else if (u_lights[i].type == 1)
            Lo += EvalPoint(u_lights[i], N, V, v_FragPos, albedo, metallic, roughness);
        else if (u_lights[i].type == 2)
            Lo += EvalSpot(u_lights[i], N, V, v_FragPos, albedo, metallic, roughness);
    }

    //vec3 color = ambient + Lo + u_Emissive;
	vec3 color_linear = max(ambient + Lo + u_Emissive, 0.0);
	vec3 color_srgb = linear_to_srgb(color_linear);
    //FragColor = vec4(max(color, 0.0), 1.0);
    FragColor = vec4(color_srgb, 1.0);
}
