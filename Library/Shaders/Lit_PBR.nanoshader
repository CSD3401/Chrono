#type vertex
#version 460 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;
layout(location = 5) in mat4 i_Model;   // per-instance model matrix (divisor=1)
layout(location = 9) in vec3 i_IDRGB;   // per-instance picking ID (0..1)

uniform mat4 u_View;
uniform mat4 u_Projection;

out vec3 v_Normal;
out vec3 v_FragPos;
out vec2 v_TexCoord;
out vec3 v_ID;

void main() {
    vec4 world = i_Model * vec4(aPos, 1.0);
    v_FragPos = world.xyz;

    // robust normal for non-uniform scale
    mat3 normalMtx = transpose(inverse(mat3(i_Model)));
    v_Normal  = normalMtx * a_Normal;

    v_TexCoord = a_TexCoord;
    v_ID = i_IDRGB;

    gl_Position = u_Projection * u_View * world;
}


#type fragment
#version 460 core
#extension GL_ARB_bindless_texture : require

#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2
#define LIGHT_TYPE_AREA 3

#define SHADOW_NONE 0
#define SHADOW_HARD 1
#define SHADOW_SOFT 2

in vec3 v_Normal;
in vec3 v_FragPos;
in vec2 v_TexCoord;
in vec3 v_ID;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 OutID;

// ===== Scene / Lighting =====
uniform vec3 	  u_CameraPos;

// Base (albedo)
uniform vec3      u_BaseColor;
uniform sampler2D u_AlbedoMap;
uniform int       h_HasAlbedoMap;

// Opacity
uniform float     u_Opacity; // scalar multiplier (default 1.0)
uniform sampler2D u_OpacityMap;
uniform int       h_HasOpacityMap;
uniform int   	  u_AlphaClip; // 0 = off (opaque/blend), 1 = clip/discard
uniform float     u_AlphaCutoff;

// Normal (BC5 packed X,Y)
uniform sampler2D u_NormalMap;
uniform int       h_HasNormalMap;

// Roughness / Metallic
uniform float     u_Roughness;
uniform sampler2D u_RoughnessMap;
uniform int       h_HasRoughnessMap;
uniform float     u_Metallic;
uniform sampler2D u_MetallicMap;
uniform int       h_HasMetallicMap;

// Ambient Occlusion
uniform float     u_AmbientOcclusion;
uniform sampler2D u_AmbientOcclusionMap;
uniform int       h_HasAOMap;

// UV Transform
uniform vec3 	  u_Tiling; // uses .xy
uniform vec3 	  u_Offset; // uses .xy

// Emissive
uniform vec3      u_Emissive;

// ===== Fog (scene-wide) =====
uniform int   	  i_FogEnabled;   // 0/1
uniform vec3  	  i_FogColor;     // linear color!
uniform int   	  i_FogMode;      // 0=Linear, 1=Exp, 2=Exp2
uniform float 	  i_FogDensity;   // Exp/Exp2
uniform float 	  i_FogStart;     // Linear
uniform float 	  i_FogEnd;       // Linear

// Scene ambient
uniform vec3 	  i_GlobalAmbientColor;
uniform float 	  i_GlobalAmbientIntensity;

// ---- Clustered lighting buffers ----
// Must match GPULightCPU in GLClusteredLighting
struct GPULight {
    vec4 position;  // xyz + type
    vec4 color;     // rgb + intensity
    vec4 params;    // inner, outer, range, shadowIndex
    vec4 direction; // xyz + padding
};
// Must match Cluster in compute shader
struct Cluster {
    uint offset;
    uint count;
    uint pad0;
    uint pad1;
};
layout(std430, binding = 0) buffer LightBuffer {
    GPULight g_Lights[];
};

layout(std430, binding = 1) buffer ClusterBuffer {
    Cluster g_Clusters[];
};

layout(std430, binding = 2) buffer ClusterLightIndices {
    uint g_ClusterLightIndices[];
};
// Must match ClusterParamsCPU in GLClusteredLighting
layout(std140, binding = 3) uniform ClusterParams {
    mat4 i_View;
    mat4 i_Projection;
	mat4 i_InvProjection;

    float i_zNear;
    float i_zFar;
    int   i_ClustersX;
    int   i_ClustersY;
    int   i_ClustersZ;

    int   i_NumLights;
    int   i_ScreenWidth;
    int   i_ScreenHeight;
};
struct Light {
    int   type; // 0 = directional, 1 = point, 2 = spot
    vec3  color;
    float intensity;

    vec3  position;
    vec3  direction;

	float innerCutoff; // cos(innerAngle)
    float outerCutoff; // cos(outerAngle)
	float range;
	
	int shadowIndex;
	int   shadowType;
};

const float PI = 3.14159265359;

// SHADOWS~!
const int MAX_SHADOWS = 16;
uniform int      	u_NumShadowMaps;
uniform mat4     	u_ShadowVP[MAX_SHADOWS];
uniform sampler2D 	u_ShadowMaps[MAX_SHADOWS];
uniform int			u_ReceiveShadows;

// ---- helpers ----
float SampleShadowHardIndexed(int shadowIndex, vec3 worldPos, vec3 normal, vec3 lightDir)
{
    if (shadowIndex < 0 || shadowIndex >= u_NumShadowMaps)
        return 1.0;

    mat4 vp = u_ShadowVP[shadowIndex];
    vec4 lightSpace = vp * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpace.xyz / lightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;

    if (projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0 ||
        projCoords.z < 0.0 || projCoords.z > 1.0)
    {
        return 1.0;
    }

    float closestDepth = texture(u_ShadowMaps[shadowIndex], projCoords.xy).r;
    float currentDepth = projCoords.z;

    float ndotl = max(dot(normalize(normal), normalize(-lightDir)), 0.0);
    float bias  = max(0.0005 * (1.0 - ndotl), 0.0005);

    return (currentDepth - bias > closestDepth) ? 0.0 : 1.0;
}

float SampleShadowSoftIndexed(int shadowIndex, vec3 worldPos, vec3 normal, vec3 lightDir)
{
    if (shadowIndex < 0 || shadowIndex >= u_NumShadowMaps)
        return 1.0;

    mat4 vp = u_ShadowVP[shadowIndex];
    vec4 lightSpace = vp * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpace.xyz / lightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;

    if (projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0 ||
        projCoords.z < 0.0 || projCoords.z > 1.0)
    {
        return 1.0;
    }

    float currentDepth = projCoords.z;

    // bias based on normal/light angle
    float ndotl = max(dot(normalize(normal), normalize(-lightDir)), 0.0);
    float bias  = max(0.0005 * (1.0 - ndotl), 0.0005);

    // 3x3 PCF around UV
    vec2 texelSize = 1.0 / vec2(textureSize(u_ShadowMaps[shadowIndex], 0));
    float shadowSum = 0.0;
    int samples = 0;

    for (int x = -1; x <= 1; ++x) {
        for (int y = -1; y <= 1; ++y) {
            vec2 offset = vec2(x, y) * texelSize;
            float closestDepth = texture(u_ShadowMaps[shadowIndex], projCoords.xy + offset).r;
            shadowSum += (currentDepth - bias > closestDepth) ? 0.0 : 1.0;
            samples++;
        }
    }

    return shadowSum / float(samples);
}

float ComputeShadowForLight(in Light L, vec3 worldPos, vec3 N)
{
    if (u_ReceiveShadows == 0)       return 1.0;
    if (L.shadowIndex < 0)          return 1.0;
    if (L.shadowType == SHADOW_NONE) return 1.0;

    // only directional + spot currently supported
    if (L.type != LIGHT_TYPE_DIRECTIONAL && L.type != LIGHT_TYPE_SPOT)
        return 1.0;

    vec3 lightDir;
    if (L.type == LIGHT_TYPE_DIRECTIONAL) {
        lightDir = -normalize(L.direction);
    } else { // SPOT
        lightDir = normalize(worldPos - L.position);
    }

    if (L.shadowType == SHADOW_HARD) {
        return SampleShadowHardIndexed(L.shadowIndex, worldPos, N, lightDir);
    } else { // SOFT
        return SampleShadowSoftIndexed(L.shadowIndex, worldPos, N, lightDir);
    }
}

float DistributionGGX(float NdotH, float rough){
    float a=max(rough,0.04); float a2=a*a;
    float denom=(NdotH*NdotH)*(a2-1.0)+1.0;
    return a2 / max(PI*denom*denom, 1e-6);
}
float GeometrySchlickGGX(float NdotX, float rough){
    float r=max(rough,0.04); float k=(r+1.0); k=(k*k)/8.0;
    return NdotX / max(NdotX*(1.0-k)+k, 1e-6);
}
float GeometrySmith(float NdotV,float NdotL,float rough){
    return GeometrySchlickGGX(NdotV,rough) * GeometrySchlickGGX(NdotL,rough);
}
vec3  FresnelSchlick(float cosTheta, vec3 F0){
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta,0.0,1.0), 5.0);
}

mat3 ComputeTBN(vec3 N, vec3 P, vec2 uv){
    vec3 dp1 = dFdx(P), dp2 = dFdy(P);
    vec2 duv1 = dFdx(uv), duv2 = dFdy(uv);
    vec3 T = normalize(dp1 * duv2.y - dp2 * duv1.y);
    vec3 B = normalize(cross(N, T));
    return mat3(T, B, N);
}

vec3 BRDF_GGX_Smith(vec3 N, vec3 V, vec3 L, vec3 albedo, float metallic, float rough){
    vec3 H = normalize(V + L);
    float NdotL = max(dot(N,L),0.0);
    float NdotV = max(dot(N,V),0.0);
    float NdotH = max(dot(N,H),0.0);
    float VdotH = max(dot(V,H),0.0);
    if (NdotL<=0.0 || NdotV<=0.0) return vec3(0.0);

    vec3 F0 = mix(vec3(0.04), albedo, metallic);
    float D = DistributionGGX(NdotH,rough);
    float G = GeometrySmith(NdotV,NdotL,rough);
    vec3  F = FresnelSchlick(VdotH, F0);

    vec3 spec = (D*G*F) / max(4.0*NdotV*NdotL, 1e-6);
    vec3 Ks = F;
    vec3 Kd = (1.0 - Ks) * (1.0 - metallic);
    vec3 diff = (Kd * albedo) / PI;
    return (diff + spec) * NdotL;
}
//fog
float FogFactor(float d){
    if (i_FogMode==0){ // Linear
        float denom = max(i_FogEnd - i_FogStart, 1e-4);
        return clamp((i_FogEnd - d) / denom, 0.0, 1.0);
    } else if (i_FogMode==1){ // Exp
        return clamp(exp(-i_FogDensity * d), 0.0, 1.0);
    } else { // Exp2
        float x = i_FogDensity * d;
        return clamp(exp(-x*x), 0.0, 1.0);
    }
}

// ---- light evaluators ----
float DistanceAttenuation(float d, float range) {
    if (range <= 0.0) return 0.0;
    float x = clamp(d / range, 0.0, 1.0);
    float att = 1.0 - x;
    return att * att; // smooth
}


vec3 EvalDirectional(in Light L, vec3 N, vec3 V, vec3 albedo, float metallic, float rough){
    vec3 Ld = normalize(-L.direction);
    vec3 brdf = BRDF_GGX_Smith(N,V,Ld,albedo,metallic,rough);
    return brdf * (L.color * L.intensity);
}

vec3 EvalPoint(in Light L, vec3 N, vec3 V, vec3 P, vec3 albedo, float metallic, float rough){
    vec3  Ldir = L.position - P;
    float dist2 = dot(Ldir,Ldir);
    float d = sqrt(dist2);
    if (d <= 0.0) return vec3(0.0);

    // hard cutoff (cheap early out)
    if (L.range > 0.0 && d > L.range) return vec3(0.0);

    vec3 Ld = Ldir / d;

    float atten = DistanceAttenuation(d, L.range);

    vec3 brdf = BRDF_GGX_Smith(N, V, Ld, albedo, metallic, rough);
    return brdf * (L.color * L.intensity * atten);
}

vec3 EvalSpot(in Light L, vec3 N, vec3 V, vec3 P, vec3 albedo, float metallic, float rough){
    vec3  Ldir = L.position - P;
    float dist2 = dot(Ldir,Ldir);
    float d = sqrt(dist2);
    if (d <= 0.0) return vec3(0.0);

    if (L.range > 0.0 && d > L.range) return vec3(0.0);

    vec3 Ld = Ldir / d;

    float theta = dot(Ld, normalize(-L.direction));
    float eps = max(L.innerCutoff - L.outerCutoff, 1e-4);
    float spot = clamp((theta - L.outerCutoff) / eps, 0.0, 1.0);
    if (spot <= 0.0) return vec3(0.0);

    float atten = DistanceAttenuation(d, L.range);

    vec3 brdf = BRDF_GGX_Smith(N, V, Ld, albedo, metallic, rough);
    return brdf * (L.color * L.intensity * atten * spot);
}

Light MakeLightFromGPULight(GPULight g) {
	Light L;
    L.type      = int(g.position.w);
    L.color     = g.color.rgb;
    L.intensity = g.color.a;

    L.position  = g.position.xyz;
    L.direction = g.direction.xyz;

    L.innerCutoff = g.params.x;
    L.outerCutoff = g.params.y;
	L.range = g.params.z;
	
	L.shadowIndex = int(g.params.w + 0.5);
	L.shadowType  = int(g.direction.w + 0.5);
	
    return L;
}

int ComputeClusterIndex(vec3 worldPos)
{
    // Screen X/Y from gl_FragCoord
    int cx = int(gl_FragCoord.x * float(i_ClustersX) / float(i_ScreenWidth));
    int cy = int(gl_FragCoord.y * float(i_ClustersY) / float(i_ScreenHeight));

    cx = clamp(cx, 0, i_ClustersX - 1);
    cy = clamp(cy, 0, i_ClustersY - 1);

    // Depth from view-space Z
    vec3 posVS = (i_View * vec4(worldPos, 1.0)).xyz;
    float d = -posVS.z; // camera looks down -Z

    float t = (d - i_zNear) / max(i_zFar - i_zNear, 1e-6);
    t = clamp(t, 0.0, 0.9999); // avoid hitting upper bound exactly

    int cz = int(t * float(i_ClustersZ));
    cz = clamp(cz, 0, i_ClustersZ - 1);

    int idx = cx + cy * i_ClustersX + cz * (i_ClustersX * i_ClustersY);
    return idx;
}

void main() {
    // UV transform
    vec2 uv = v_TexCoord * u_Tiling.xy + u_Offset.xy;

    // View / normal
    vec3 V = normalize(u_CameraPos - v_FragPos);
    vec3 N = normalize(v_Normal);

    // Albedo
	vec3 albedo = u_BaseColor;
	if (h_HasAlbedoMap != 0){
		albedo *= texture(u_AlbedoMap, uv).rgb;
	}
	
	// Opacity
	float opacity = clamp(u_Opacity, 0.0, 1.0);
	if (h_HasOpacityMap != 0) {
		opacity *= clamp(texture(u_OpacityMap, uv).r, 0.0, 1.0);
	}
	
	// Alpha clip
	if (u_AlphaClip != 0) {
		if (opacity < u_AlphaCutoff) 
			discard;
	}

    // Normal map (BC5 XY)
    if (h_HasNormalMap != 0){
        vec2 enc = texture(u_NormalMap, uv).rg * 2.0 - 1.0;
        float z = sqrt(max(1.0 - dot(enc, enc), 0.0));
        vec3 n = vec3(enc, z);
        mat3 TBN = ComputeTBN(N, v_FragPos, uv);
        N = normalize(TBN * n);
    }

    // Roughness/Metallic
    float rough = clamp(u_Roughness, 0.04, 1.0);
    if (h_HasRoughnessMap != 0) rough = clamp(texture(u_RoughnessMap, uv).r, 0.04, 1.0);

    float metal = clamp(u_Metallic, 0.0, 1.0);
    if (h_HasMetallicMap  != 0) metal  = clamp(texture(u_MetallicMap,  uv).r, 0.0, 1.0);

    // Ambient Occlusion
    float ao = 1.0;
    if (h_HasAOMap != 0) {
        ao = clamp(texture(u_AmbientOcclusionMap, uv).r, 0.0, 1.0);
    }

    // Ambient term
    vec3 ambient = i_GlobalAmbientColor * i_GlobalAmbientIntensity * albedo * ao;

    vec3 Lo = vec3(0.0);

    if (i_NumLights > 0) {
        int clusterIndex = ComputeClusterIndex(v_FragPos);
        Cluster c = g_Clusters[clusterIndex];

        uint offset = c.offset;
        uint count  = c.count;

		for (uint i = 0u; i < count; ++i) {
			uint lightIdx = g_ClusterLightIndices[offset + i];
			if (lightIdx >= uint(i_NumLights)) continue;

			GPULight gL = g_Lights[lightIdx];
			Light L     = MakeLightFromGPULight(gL);

			float shadow = ComputeShadowForLight(L, v_FragPos, N);

			vec3 contrib = vec3(0.0);
			if (L.type == LIGHT_TYPE_DIRECTIONAL) {
				contrib = EvalDirectional(L, N, V, albedo, metal, rough);
			} else if (L.type == LIGHT_TYPE_POINT) {
				contrib = EvalPoint(L, N, V, v_FragPos, albedo, metal, rough);
			} else if (L.type == LIGHT_TYPE_SPOT) {
				contrib = EvalSpot(L, N, V, v_FragPos, albedo, metal, rough);
			}

			Lo += contrib * shadow;
		}
    }

    vec3 color_linear = max(ambient + Lo + u_Emissive, 0.0);

    if (i_FogEnabled == 1){
        float d  = distance(u_CameraPos, v_FragPos);
        float ff = FogFactor(d);
        color_linear = mix(i_FogColor, color_linear, ff);
    }

    FragColor = vec4(color_linear, opacity);
    OutID = vec4(v_ID, 1.0);
}
