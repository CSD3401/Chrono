#type vertex
#version 460 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;

uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;
uniform mat4 u_NormalMatrix;

out vec3 v_Normal;
out vec3 v_FragPos;
out vec2 v_TexCoord;

void main() {
    //v_Normal = mat3(u_Model) * a_Normal;
    v_Normal = normalize((u_NormalMatrix * vec4(a_Normal, 0.0)).xyz);
    v_FragPos = vec3(u_Model * vec4(aPos, 1.0));
    v_TexCoord = a_TexCoord;
    gl_Position = u_Projection * u_View * u_Model * vec4(aPos, 1.0);
}

#type fragment
#version 460 core

#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2

const float PI = 3.14159265358979323846;

struct Light {
	int type;
	vec3 position;
	vec3 color;
	vec3 direction;
	float intensity;
	float innerCutoff;
	float outerCutoff;
	float constant;
	float linear;
	float quadratic;
};

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

#define MAX_LIGHTS 12

in vec3 v_Normal;
in vec3 v_FragPos;
in vec2 v_TexCoord;

uniform int u_numLights;
uniform Light u_lights[MAX_LIGHTS];

uniform vec3 u_CameraPos;
uniform Material u_Material;

uniform int u_ShadingModel; 
uniform vec3 u_BaseColor = vec3(1.0, 0.0, 0.0); 
uniform float u_Metallic = 0.8; 
uniform float u_Roughness = 0.2;

uniform float u_AmbientIntensity = 0.06;

out vec4 FragColor;

vec3 CalcDirectionalLight(Light light, vec3 normal, vec3 viewDir) {
    vec3 lightDir = normalize(-light.direction);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Material.shininess);
    vec3 ambient = u_Material.ambient * light.color * light.intensity;
    vec3 diffuse = diff * u_Material.diffuse * light.color * light.intensity;
    vec3 specular = spec * u_Material.specular * light.color * light.intensity;
    return ambient + diffuse + specular;
}

vec3 CalcPointLight(Light light, vec3 normal, vec3 fragPos, vec3 viewDir) {
    vec3 lightDir = normalize(light.position - fragPos);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Material.shininess);
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * distance * distance);
    vec3 ambient = u_Material.ambient * light.color * light.intensity;
    vec3 diffuse = diff * u_Material.diffuse * light.color * light.intensity;
    vec3 specular = spec * u_Material.specular * light.color * light.intensity;
    return (ambient + diffuse + specular) * attenuation;
}

vec3 CalcSpotLight(Light light, vec3 normal, vec3 fragPos, vec3 viewDir) {
    vec3 lightDir = normalize(light.position - fragPos);
    float theta = dot(lightDir, normalize(-light.direction));
    float epsilon = light.innerCutoff - light.outerCutoff;
    float intensity = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Material.shininess);
    float distance = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * distance * distance);
    vec3 ambient = u_Material.ambient * light.color * light.intensity;
    vec3 diffuse = diff * u_Material.diffuse * light.color * light.intensity;
    vec3 specular = spec * u_Material.specular * light.color * light.intensity;
    return (ambient + diffuse + specular) * attenuation * intensity;
}

float D_GGX(vec3 N, vec3 H, float roughness) { 
    float a = roughness * roughness; 
    float a2 = a * a; float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH; 
    float denom = (NdotH2 * (a2 - 1.0) + 1.0); 
    return a2 / (PI * denom * denom); 
}

float G_SchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;  // Direct lighting k
    return NdotV / (NdotV * (1.0 - k) + k);
}

float G_Smith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = G_SchlickGGX(NdotV, roughness);
    float ggx1 = G_SchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

vec3 F_Schlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 EvaluateLight_PBR(Light light, vec3 N, vec3 V, vec3 P, vec3 baseColor, float metallic, float roughness) {
    vec3 L;
    vec3 radiance;
    
	float epsilon = light.innerCutoff - light.outerCutoff;
    // Calculate light direction and radiance with attenuation
    if (light.type == LIGHT_TYPE_DIRECTIONAL) {
        L = normalize(-light.direction);
        radiance = light.color * light.intensity;
    } else {
        L = normalize(light.position - P);
        float distance = length(light.position - P);
        float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * distance * distance);
        radiance = light.color * light.intensity * attenuation;
        
        // Handle spot light cone
        if (light.type == LIGHT_TYPE_SPOT) {
            float theta = dot(L, normalize(-light.direction));
            
            float spotIntensity = clamp((theta - light.outerCutoff) / epsilon, 0.0, 1.0);
            radiance *= spotIntensity;
        }
    }
    
    vec3 H = normalize(V + L);
    
    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);
    float HdotV = max(dot(H, V), 0.0);
    
    if (NdotL <= 0.0 || NdotV <= 0.0) return vec3(0.0);
    
    // Calculate F0 (surface reflection at zero incidence)
    vec3 F0 = mix(vec3(0.04), baseColor, metallic);
    
    // Cook-Torrance BRDF components
    float D = D_GGX(N, H, roughness);
    float G = G_Smith(N, V, L, roughness);
    vec3 F = F_Schlick(HdotV, F0);
    
    // Calculate specular BRDF
    vec3 numerator = D * G * F;
    float denominator = 4.0 * NdotV * NdotL + epsilon; // Small epsilon to prevent division by zero
    vec3 specular = numerator / denominator;
    
    // Energy conservation
    vec3 kS = F;  // Fresnel gives us the specular contribution
    vec3 kD = vec3(1.0) - kS;  // Remaining energy is diffuse
    kD *= 1.0 - metallic;  // Metallic surfaces have no diffuse reflection
    
    // Lambertian diffuse
    vec3 diffuse = kD * baseColor / PI;

    // Simple ambient for now
	float u_AO = 1.0;
    vec3 ambient = 0.03 * u_BaseColor * u_AO;
    
    return ((diffuse + specular) * radiance * NdotL) + ambient;
}

void main() {
    //FragColor = vec4(1.0, 0.5, 0.2, 1.0);
    FragColor = vec4(normalize(v_Normal) * 0.5 + 0.5, 1.0); 
    vec3 norm = normalize(v_Normal);
    vec3 viewDir = normalize(u_CameraPos - v_FragPos);
    vec3 result = vec3(0.0);
	//result += (u_numLights == 0 ? 0.06 : 0.0) * u_BaseColor;
	// ---- Base ambient (always-on so back/side faces aren’t pitch black)
	const float kAmbient = 0.06;  // tweak 0.04–0.10 for demo
	float ao = 1.0;               // no AO available in this scope
	result += kAmbient * u_BaseColor * ao;
	
    if (u_ShadingModel == 0)
    {
        for (int i = 0; i < u_numLights; ++i) {
            if (u_lights[i].type == 0)
                result += CalcDirectionalLight(u_lights[i], norm, viewDir);
            else if (u_lights[i].type == 1)
                result += CalcPointLight(u_lights[i], norm, v_FragPos, viewDir);
            else if (u_lights[i].type == 2)
                result += CalcSpotLight(u_lights[i], norm, v_FragPos, viewDir);
        }
    }
    else if (u_ShadingModel == 1)
    {
        // PBR shading
        for (int i = 0; i < u_numLights && i < MAX_LIGHTS; ++i) 
        {
            result += EvaluateLight_PBR(u_lights[i], norm, viewDir, v_FragPos, u_BaseColor, u_Metallic, u_Roughness);
        }
        
        // Tone mapping
        result = result / (result + vec3(1.0));
        
        // Gamma correction
        result = pow(result, vec3(1.0/2.2));
    }

    FragColor = vec4(result, 1.0);
}