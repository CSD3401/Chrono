#type vertex
#version 460 core

layout(location = 0) in vec3 a_Position;

uniform mat4 u_View;
uniform mat4 u_Projection;

out vec3 v_Dir;

void main() {
    mat4 viewNoTrans = mat4(mat3(u_View));
    v_Dir = a_Position;

    vec4 p = u_Projection * viewNoTrans * vec4(a_Position, 1.0);
    gl_Position = p.xyww;
}

#type fragment
#version 460 core

in vec3 v_Dir;

out vec4 FragColor;

void main() {
    vec3 dir = normalize(v_Dir);

    // 0 at horizon, 1 at zenith
    float up = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);

    // Sharper shaping for nicer gradient
    float zenithW  = pow(up, 1.8);
    float horizonW = pow(1.0 - abs(dir.y), 3.5); // thin band around horizon

    // Base sky colors (linear, HDR-friendly)
    vec3 zenithCol  = vec3(0.08, 0.18, 0.55) * 1.2;
    vec3 horizonCol = vec3(0.55, 0.72, 1.05) * 1.1;

    // Main gradient
    vec3 sky = mix(horizonCol, zenithCol, zenithW);

    // Horizon haze glow (slightly warm)
    vec3 hazeCol = vec3(1.10, 0.95, 0.80) * 0.35;
    sky += hazeCol * horizonW;

    // Sun (pick a direction in world space; tune as you like)
    vec3 sunDir = normalize(vec3(0.25, 0.55, 0.25));
    float sunCos = max(dot(dir, sunDir), 0.0);

    // Sun disc + bloom lobe (HDR)
    float sunDisc  = smoothstep(0.9994, 1.0, sunCos);       // tiny disc
    float sunBloom = pow(sunCos, 180.0) * 0.8 + pow(sunCos, 32.0) * 0.25;

    vec3 sunCol = vec3(1.15, 1.05, 0.90) * 8.0;             // bright in linear HDR
    sky += sunCol * (sunDisc * 1.0 + sunBloom);

    // Gentle overall exposure (still linear; tonemap later)
    sky *= 1.0;

    FragColor = vec4(sky, 1.0);
}