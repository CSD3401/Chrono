#type vertex
#version 460 core

layout(location = 0) in vec3 a_Position;

uniform mat4 u_View;
uniform mat4 u_Projection;

out vec3 v_Dir;

void main() {
    mat4 viewNoTrans = mat4(mat3(u_View));
    v_Dir = a_Position;

    vec4 p = u_Projection * viewNoTrans * vec4(a_Position, 1.0);
    gl_Position = p.xyww;
}

#type fragment
#version 460 core

in vec3 v_Dir;
out vec4 FragColor;

// Hash helpers (fast, stable)
float hash11(float p) {
    p = fract(p * 0.1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

float hash31(vec3 p) {
    p = fract(p * 0.1031);
    p += dot(p, p.yzx + 33.33);
    return fract((p.x + p.y) * p.z);
}

// Starfield using a jittered grid on the unit sphere direction
float starField(vec3 dir, float density, float size, float twinkleStrength) {
    // Project direction to a pseudo 2D domain (cheap spherical mapping)
    // Avoid seams by using a 3D grid instead of 2D UVs
    vec3 p = normalize(dir) * 120.0;          // frequency control
    vec3 cell = floor(p);
    vec3 f = fract(p);

    // Pick one star candidate per cell (could do more, but this is already nice)
    float rnd = hash31(cell);
    float on = step(1.0 - density, rnd);      // density: 0..1 (higher = more stars)

    // Random star position within the cell
    vec3 starPos = vec3(hash31(cell + 1.3), hash31(cell + 2.1), hash31(cell + 3.7));
    vec3 d = f - starPos;

    // Star shape (tiny soft blob)
    float r2 = dot(d, d);
    float star = exp(-r2 / max(1e-5, size));  // size ~ 0.002..0.02 depending on scale

    // Twinkle (subtle)
    float tw = 1.0 + (hash11(rnd * 91.7) - 0.5) * twinkleStrength;

    return on * star * tw;
}

void main() {
    vec3 dir = normalize(v_Dir);

    // Night gradient: horizon slightly brighter, zenith darker
    float up = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
    float zenithW  = pow(up, 1.6);
    float horizonW = pow(1.0 - abs(dir.y), 2.8);

    vec3 zenithCol  = vec3(0.01, 0.02, 0.06);      // deep navy
    vec3 horizonCol = vec3(0.03, 0.04, 0.07);      // slightly brighter

    vec3 sky = mix(horizonCol, zenithCol, zenithW);

    // Subtle horizon haze (cool, not warm at night)
    sky += vec3(0.05, 0.06, 0.08) * 0.15 * horizonW;

    // Stars (two layers: small dense + larger sparse)
    float s1 = starField(dir, 0.035, 0.010, 0.20); // dense tiny stars
    float s2 = starField(dir * 1.37, 0.010, 0.030, 0.35); // fewer bigger stars

    // Star color variation (slight temperature changes)
    float t = clamp(hash31(floor(normalize(dir) * 500.0)) , 0.0, 1.0);
    vec3 starCol = mix(vec3(0.85, 0.90, 1.05), vec3(1.05, 0.95, 0.85), t);

    // Boost intensity in HDR so bloom can pick them up if you want
    sky += starCol * (s1 * 2.0 + s2 * 3.5);

    // Optional moon (soft disc + glow)
    vec3 moonDir = normalize(vec3(-0.35, 0.55, -0.15));
    float moonCos = max(dot(dir, moonDir), 0.0);

    float moonDisc = smoothstep(0.9996, 1.0, moonCos);
    float moonGlow = pow(moonCos, 220.0) * 0.8 + pow(moonCos, 18.0) * 0.15;

    vec3 moonCol = vec3(0.95, 0.98, 1.05) * 3.0;   // HDR moon
    sky += moonCol * (moonDisc * 1.2 + moonGlow);

    FragColor = vec4(sky, 1.0);
}