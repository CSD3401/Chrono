#type vertex
#version 460 core

layout(location = 0) in vec2 aPos;
layout(location = 1) in vec2 aUV;

out vec2 vUV;

void main() {
    vUV = aUV;
    gl_Position = vec4(aPos, 0.0, 1.0);
}

#type fragment
#version 460 core

in vec2 vUV;
out float FragAO;

uniform sampler2D u_Depth;

// camera data
uniform mat4  u_InvProj;
uniform float u_Radius;
uniform float u_Bias;
uniform float u_Intensity;
uniform float u_Power;

// Reconstruct view-space position from depth
vec3 ReconstructViewPos(vec2 uv, float depth)
{
    // depth is assumed to be non-linear [0,1] from projection
    float z = depth * 2.0 - 1.0;
    vec4 clip = vec4(uv * 2.0 - 1.0, z, 1.0);
    vec4 view = u_InvProj * clip;
    return view.xyz / view.w;
}

void main()
{
    float centerDepth = texture(u_Depth, vUV).r;
    if (centerDepth >= 1.0) {
        FragAO = 1.0;
        return;
    }

    vec3 centerPos = ReconstructViewPos(vUV, centerDepth);

    // approximate normal from depth gradient
    vec2 texel = 1.0 / vec2(textureSize(u_Depth, 0));
    float depthR = texture(u_Depth, vUV + vec2(texel.x, 0)).r;
    float depthU = texture(u_Depth, vUV + vec2(0, texel.y)).r;

    vec3 posR = ReconstructViewPos(vUV + vec2(texel.x, 0), depthR);
    vec3 posU = ReconstructViewPos(vUV + vec2(0, texel.y), depthU);

    vec3 dx = posR - centerPos;
    vec3 dy = posU - centerPos;
    vec3 normal = normalize(cross(dy, dx));

    // small fixed sample pattern (screen-space ring)
    const int SAMPLE_COUNT = 8;
    vec2 offsets[SAMPLE_COUNT] = vec2[](
        vec2( 1,  0),
        vec2(-1,  0),
        vec2( 0,  1),
        vec2( 0, -1),
        vec2( 1,  1),
        vec2(-1,  1),
        vec2( 1, -1),
        vec2(-1, -1)
    );

    float occlusion = 0.0;

    for (int i = 0; i < SAMPLE_COUNT; ++i) {
        vec2 sampleUV = vUV + offsets[i] * texel * u_Radius * 4.0;
        if (sampleUV.x < 0.0 || sampleUV.x > 1.0 ||
            sampleUV.y < 0.0 || sampleUV.y > 1.0)
            continue;

        float sd = texture(u_Depth, sampleUV).r;
        if (sd >= 1.0) continue;

        vec3 samplePos = ReconstructViewPos(sampleUV, sd);

        vec3 dir = samplePos - centerPos;
        float dist = length(dir);
        dir = normalize(dir);

        float NdotD = max(dot(normal, dir), 0.0);

        float rangeCheck = smoothstep(0.0, 1.0, u_Radius / (dist + 1e-4));
        float deltaDepth = samplePos.z - centerPos.z;

        if (deltaDepth > u_Bias && dist < u_Radius) {
            occlusion += NdotD * rangeCheck;
        }
    }

    float ao = 1.0 - (occlusion / float(SAMPLE_COUNT));
    ao = pow(clamp(ao, 0.0, 1.0), u_Power);

    // store AO in [0,1], intensity applied later in composite
    FragAO = ao;
}
