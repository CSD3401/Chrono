#type vertex
#version 460 core

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;

uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;
uniform mat4 u_NormalMatrix;

out vec3 v_Normal;
out vec3 v_FragPos;
out vec2 v_TexCoord;

void main() {
    vec4 world = u_Model * vec4(aPos, 1.0);
    v_FragPos  = world.xyz;

    v_Normal   = normalize(mat3(u_NormalMatrix) * a_Normal);

    v_TexCoord = a_TexCoord;
    gl_Position = u_Projection * u_View * world;
}

#type fragment
#version 460 core

#define MAX_LIGHTS 12
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2

struct Light {
	int type;
	vec3 position;
	vec3 color;
	vec3 direction;
	float intensity;
	float innerCutoff;
	float outerCutoff;
	float constant;
	float linear;
	float quadratic;
};

struct Material {
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
};

in vec3 v_Normal;
in vec3 v_FragPos;
in vec2 v_TexCoord;

out vec4 FragColor;

uniform int u_numLights;
uniform Light u_lights[MAX_LIGHTS];

uniform vec3 u_CameraPos;
uniform Material u_Material;

uniform vec3 u_BaseColor = vec3(1.0, 0.0, 0.0); 
uniform float u_AO = 1.0;

vec3 BlinnSpec(vec3 N, vec3 L, vec3 V, float shininess, vec3 specColor) {
    vec3 H = normalize(L + V);
    float spec = pow(max(dot(N, H), 0.0), shininess);
    return spec * specColor;
}

vec3 CalcDirectionalLight(Light light, vec3 N, vec3 V, vec3 baseColor, float shininess) {
    vec3 L = normalize(-light.direction);
    float ndotl = max(dot(N, L), 0.0);
    vec3 diffuse  = ndotl * baseColor * light.color * light.intensity;
    vec3 specular = (ndotl > 0.0) ? BlinnSpec(N, L, V, shininess, light.color * light.intensity) : vec3(0);
    return diffuse + specular;
}

vec3 CalcPointLight(Light light, vec3 N, vec3 pos, vec3 V, vec3 baseColor, float shininess) {
    vec3 Ldir = light.position - pos;
    float d = length(Ldir);
    vec3 L = (d > 0.0) ? Ldir / d : vec3(0,0,1);
    float ndotl = max(dot(N, L), 0.0);
    float atten = 1.0 / (light.constant + light.linear * d + light.quadratic * d * d);

    vec3 diffuse  = ndotl * baseColor * light.color;
    vec3 specular = (ndotl > 0.0) ? BlinnSpec(N, L, V, shininess, light.color) : vec3(0);
    return (diffuse + specular) * atten * light.intensity;
}

vec3 CalcSpotLight(Light light, vec3 N, vec3 pos, vec3 V, vec3 baseColor, float shininess) {
    vec3 Ldir = light.position - pos;
    float d = length(Ldir);
    vec3 L = (d > 0.0) ? Ldir / d : vec3(0,0,1);

    // Spotlight falloff
    float theta = dot(L, normalize(-light.direction));   // using cosine space
    float inner = light.innerCutoff;  // cos(angleInner)
    float outer = light.outerCutoff;  // cos(angleOuter)
    float eps   = max(inner - outer, 1e-4);
    float spot  = clamp((theta - outer) / eps, 0.0, 1.0); // or smoothstep(outer, inner, theta)

    float ndotl = max(dot(N, L), 0.0);
    float atten = 1.0 / (light.constant + light.linear * d + light.quadratic * d * d);

    vec3 diffuse  = ndotl * baseColor * light.color;
    vec3 specular = (ndotl > 0.0) ? BlinnSpec(N, L, V, shininess, light.color) : vec3(0);
    return (diffuse + specular) * atten * spot * light.intensity;
}

const vec3 u_AmbientColor = vec3(0.5); // non uniform for now

void main() {
	vec3 N = normalize(v_Normal);                     // world-space
	vec3 V = normalize(u_CameraPos - v_FragPos);      // world-space
	vec3 result = vec3(0.0);

	// small ambient regardless of lights
	result += u_AmbientColor * u_BaseColor * u_AO;

	for (int i = 0; i < u_numLights; ++i) {
		if (u_lights[i].type == 0)
			result += CalcDirectionalLight(u_lights[i], N, V, u_BaseColor, u_Material.shininess);
		else if (u_lights[i].type == 1)
			result += CalcPointLight(u_lights[i], N, v_FragPos, V, u_BaseColor, u_Material.shininess);
		else if (u_lights[i].type == 2)
			result += CalcSpotLight(u_lights[i], N, v_FragPos, V, u_BaseColor, u_Material.shininess);
	}
	FragColor = vec4(result, 1.0);
}
